玩法： 游戏开始，在4x4的棋盘上有两个数字，通过方向键移动它们。
每次移动，棋盘上都会增加一个数字，相同的数字会相加合并到一起，你要做的就是拼出2048！
格子尺寸：107*107
对象分析：窗口JFrame 面板JPanel 棋盘wall 数字方块 cell 得分 score 
棋盘 width=500px height=500px;格子width=105px;格子间隙 16px;
墙的颜色 new Color(184,175,158)
空格子颜色new Color(204,192,178)
字体颜色new Color(255,247,235)
2的颜色 new Color(238,228,218)
4的颜色 new Color(236,224,200)
8的颜色 new Color(242，177，121)
16的颜色 new Color(245,199,49)
32的颜色 new Color(245,124,95)	
64的颜色 new Color(246,93,59)
128的颜色 new Color(237,106,113)
256的颜色 new Color(237,204,97)
512的颜色 new Color(236,200,80)
1024的颜色 new Color(237,197,63)
2048的颜色red

自动移动模块实现思路：
==========================第一步考虑 ============================================
	weight1=4
 	四个方向移动后  空格子多的那个权重就高  根据空格多少进行排序 依次为 probability1=（4 3 2 1） * weight1/10
		
=========================第二步考虑 =============================================
  
	a weight2a=4  四个方向移动后  新生成的格子  看新格子当前行或者列有没有数字相同的格子靠着下一步可以直接合成  
	有的话  probability2 = probability2a = 4*weight2a/10
		   a1 左右移动的时候 当前行好判断 就看当前行离它最近的格子数字是否相等
		   	当前列的判断 有两种情况：一个是新格子上下两边都有格子  一个是只有一边有格子 
		   a2 上下移动的时候 当前列好判断 就看当前列离它最近的格子数字 
		   	当前行的判断 有两种情况：一个是新格子左右两边都有格子 一个是只有一边有格子
	 b weight2b=3 假如移动之后生成的新格子当前行或列 没有2或者4可以通过一步移动合成
	 	 就考虑平滑性 看离生成的小格子数最接近的 越接近 probabability越大
	    分别为probability2 = probability2b=（4 3 2 1）*weight2b/10
	   	
	---------------------------------------------------------------------
	   	（整个第二步考虑 可以遍历新生成格子当前行和列的所有格子 
	   		1 ）先判断当前行或者列有没有数字相等的格子 如果有的话 再判断相等数字的格子是不是相邻或者中间没有格子 
	   		2 ）如果没有 则判断平滑性	
========================第三步考虑================================================	   
  	
	a weight3a = 3 四个方向移动后  面板上的格子 在当前行和列可以直接合成新数字  
	
	b weight3b = 2 假如移动后 面板上的格子 不能直接合成 则考虑平滑性   

=======================第四步考虑=================================================	   
 weight4=2 四个方向移动后  哪个方向移动合成的数比较大  probability = （4 3 2 1）*weight/10 

================================================================================	
最后 probability = probability1+probability2+probability3+probability4





